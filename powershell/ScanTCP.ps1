param(
    [string]$targetHost,
    [string]$targetPorts,
    [int]$localPort = 443,
    [int]$timeout = 1000
)

function Show-Help {
    Write-Host "Usage: powershell -ExecutionPolicy Bypass -File ScanTCP.ps1 -targetHost <IP or hostname> -targetPorts <Ports to scan separated by commas> [-localPort <Port to use when scanning>] [-timeout <Timeout in milliseconds>]"
    Write-Host "Example: powershell -ExecutionPolicy Bypass -File ScanTCP.ps1 -targetHost 10.0.0.152 -targetPorts 80,443,139,22,1433,3306 -localPort 443 -timeout 1000"
    exit
}

if ($targetHost -eq "" -or $targetPorts -eq "") {
    Show-Help
}

function Connect-Port {
    param(
        [string]$remoteHost,
        [int]$remotePort,
        [int]$localPort,
        [int]$timeout
    )

    $tcpClient = New-Object System.Net.Sockets.TcpClient

    $localEndPoint = New-Object System.Net.IPEndPoint ([System.Net.IPAddress]::Any, $localPort)
    $tcpClient.Client.Bind($localEndPoint)

    try {
        $asyncResult = $tcpClient.BeginConnect($remoteHost, $remotePort, $null, $null)
        if ($asyncResult.AsyncWaitHandle.WaitOne($timeout, $false)) {
            if ($tcpClient.Connected) {
                Write-Host "$remotePort/TCP open"
            } else {
                Write-Host "$remotePort/TCP closed"
            }
        } else {
            Write-Host "$remotePort/TCP closed or timed out"
        }
    } catch {
        Write-Host "$remotePort/TCP closed"
    } finally {
        $tcpClient.Close()
    }
}

$portArray = $targetPorts -split ',' | ForEach-Object { [int]$_ }

foreach ($port in $portArray) {
    Connect-Port -remoteHost $targetHost -remotePort $port -localPort $localPort -timeout $timeout
}
